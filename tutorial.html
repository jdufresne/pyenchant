

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tutorial &mdash; PyEnchant 3.1.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Listing" href="api/index.html" />
    <link rel="prev" title="Installation" href="install.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> PyEnchant
          

          
          </a>

          
            
            
              <div class="version">
                3.1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-pyenchant-usage">Basic PyEnchant usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-and-using-dictionary-objects">Creating and Using Dictionary Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#personal-word-lists">Personal Word Lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checking-entire-blocks-of-text">Checking entire blocks of text</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wxspellcheckerdialog">wxSpellCheckerDialog</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cmdlinechecker">CmdLineChecker</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tokenization-splitting-text-into-words">Tokenization: splitting text into words</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#chunkers">Chunkers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#filters">Filters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-pyenchant-usage">Advanced PyEnchant Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#providers">Providers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#brokers">Brokers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-default-broker">The Default Broker</a></li>
<li class="toctree-l4"><a class="reference internal" href="#provider-ordering">Provider Ordering</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#extending-enchant-tokenize">Extending enchant.tokenize</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api/index.html">API Listing</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="shootout.html">Provider Shootout</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyEnchant</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Tutorial</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/tutorial.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="basic-pyenchant-usage">
<h2>Basic PyEnchant usage<a class="headerlink" href="#basic-pyenchant-usage" title="Permalink to this headline">¶</a></h2>
<p>Once installed, PyEnchant’s functionality is available in the “enchant” module.</p>
<div class="section" id="creating-and-using-dictionary-objects">
<h3>Creating and Using Dictionary Objects<a class="headerlink" href="#creating-and-using-dictionary-objects" title="Permalink to this headline">¶</a></h3>
<p>The most important object in the PyEnchant module is the Dict object, which represents a dictionary. These objects are used to check the spelling of words and to get suggestions for misspelled words. The following shows how to construct a simple Dict and use it to check some words:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">enchant</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">&quot;Helo&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Dictionaries are created using a language tag which specifies the language to be checked - in this case, “en_US” signifies American English. If the language tag is not specified, an attempt is made to determine the language currently in use. This is not always possible, in which case an Error is raised.</p>
<p>When the current language can be determined, it operates as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">tag</span>
<span class="go">&#39;en_AU&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">d</span><span class="o">.</span><span class="n">tag</span>
<span class="go">en_AU</span>
</pre></div>
</div>
<p>Of course, this may still fail if the appropriate dictionary is not available. If it cannot be determined, the behavior is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;enchant/__init__.py&quot;</span>, line <span class="m">467</span>, in <span class="n">__init__</span>
    <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="gr">enchant.Error</span>: <span class="n">No tag specified and default language could not be determined.</span>
</pre></div>
</div>
<p>There are several top-level functions in the enchant module which can be used to deal with dictionaries:</p>
<blockquote>
<div><ul class="simple">
<li><p>dict_exists: Check whether a Dict is available for a given language</p></li>
<li><p>request_dict: Construct and return a new Dict object</p></li>
<li><p>list_languages: List the languages for which Dicts are available</p></li>
</ul>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">dict_exists</span><span class="p">(</span><span class="s2">&quot;fake&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">dict_exists</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">request_dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">&lt;enchant.Dict object at 0x2aaaabdffa50&gt;cl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">list_languages</span><span class="p">()</span>
<span class="go">[&#39;en&#39;, &#39;en_CA&#39;, &#39;en_GB&#39;, &#39;en_US&#39;, &#39;eo&#39;, &#39;fr&#39;, &#39;fr_CH&#39;, &#39;fr_FR&#39;]</span>
</pre></div>
</div>
<p>As shown previously, the check method of a Dict object can be used to check whether a word is correctly spelled. To get suggestions for a misspelled word, use the suggest method as shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">suggest</span><span class="p">(</span><span class="s2">&quot;Helo&quot;</span><span class="p">)</span>
<span class="go">[&#39;He lo&#39;, &#39;He-lo&#39;, &#39;Hello&#39;, &#39;Helot&#39;, &#39;Help&#39;, &#39;Halo&#39;, &#39;Hell&#39;, &#39;Held&#39;, &#39;Helm&#39;, &#39;Hero&#39;, &quot;He&#39;ll&quot;]</span>
</pre></div>
</div>
<p>The suggestions are returned in a list, ordered from most likely replacement to least likely.</p>
<p>Once a correction is made to a miss-spelled word, it is often useful to store this correction in some way for later use. The Dict object provides several methods to handle this:</p>
<blockquote>
<div><ul class="simple">
<li><p>add: store an unrecognised word in the user’s personal dictionary so that it is recognised as correct in the future.</p></li>
<li><p>remove: store a recognised word in the user’s personal exclude list, so that it is identified as an error in the future.</p></li>
<li><p>add_to_session: store an unrecognised word so that it will be recognised as correct while the Dict object is still in use.</p></li>
<li><p>store_replacement: note that one word was used to replace another, meaning that it will appear higher in the list of suggestions in the future.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="personal-word-lists">
<h3>Personal Word Lists<a class="headerlink" href="#personal-word-lists" title="Permalink to this headline">¶</a></h3>
<p>Dict objects can also be used to check words against a custom list of correctly-spelled words known as a Personal Word List. This is simply a file listing the words to be considered, one word per line. The following example creates a Dict object for the personal word list stored in “mywords.txt”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pwl</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">request_pwl_dict</span><span class="p">(</span><span class="s2">&quot;mywords.txt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The personal word list Dict object can be used in the same way as Dict objects which reference a language dictionary. When the object’s add method is called, new entries will be appended to the bottom of the file.</p>
<p>PyEnchant also provides the class DictWithPWL which can be used to combine a language dictionary and a personal word list file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">DictWithPWL</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="s2">&quot;mywords.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="checking-entire-blocks-of-text">
<h3>Checking entire blocks of text<a class="headerlink" href="#checking-entire-blocks-of-text" title="Permalink to this headline">¶</a></h3>
<p>While the enchant.Dict objects are useful for spellchecking individual words, they cannot be used directly to check, for example, an entire paragraph. The module enchant.checker provides a class SpellChecker which is designed to handle this task.</p>
<p>SpellChecker objects are created in the same way as Dict objects - by passing a language tag to the constructor. The set_text method is used to set the text which is to be checked. Once this is done, the SpellChecker object can be used as an iterator over the spelling mistakes in the text. This is best illustrated by a simple example. The following code will print out the errors encountered in a string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enchant.checker</span> <span class="kn">import</span> <span class="n">SpellChecker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span> <span class="o">=</span> <span class="n">SpellChecker</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s2">&quot;This is sme sample txt with erors.&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">chkr</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="s2">&quot;ERROR:&quot;</span><span class="p">,</span> <span class="n">err</span><span class="o">.</span><span class="n">word</span>
<span class="gp">...</span>
<span class="go">ERROR: sme</span>
<span class="go">ERROR: txt</span>
<span class="go">ERROR: erors</span>
</pre></div>
</div>
<p>The SpellChecker can use filters to ignore certain word forms, by passing a list of filters in as a keyword argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enchant.checker</span> <span class="kn">import</span> <span class="n">SpellChecker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enchant.tokenize</span> <span class="kn">import</span> <span class="n">EmailFilter</span><span class="p">,</span> <span class="n">URLFilter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span> <span class="o">=</span> <span class="n">SpellChecker</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="n">filters</span><span class="o">=</span><span class="p">[</span><span class="n">EmailFilter</span><span class="p">,</span><span class="n">URLFilter</span><span class="p">])</span>
</pre></div>
</div>
<p>The iterator paradigm can be used to implement a wide variety of spellchecking functionality. As examples of how this can be done, PyEnchant provides a wxPython-based spellchecking dialog and a command-line spellchecking program. While intended mainly as functionality demos, they are also quite useful in their own right.</p>
</div>
<div class="section" id="wxspellcheckerdialog">
<h3>wxSpellCheckerDialog<a class="headerlink" href="#wxspellcheckerdialog" title="Permalink to this headline">¶</a></h3>
<p>The module enchant.checker.wxSpellCheckerDialog provides the class wxSpellCheckerDialog which can be used to interactively check the spelling of some text. The code below shows how to create and use such a dialog from within a wxPython application.</p>
<p>It will pop up a simple spellchecking dialog like the one shown here. Each spelling error is highlighted in turn, with the buttons offering a range of options for how to deal with the error:</p>
<blockquote>
<div><ul class="simple">
<li><p>Ignore: ignore the current occurrence of the word</p></li>
<li><p>Ignore All: ignore the current and all future occurrences of the word</p></li>
<li><p>Replace: replace the current occurrence with the corrected word</p></li>
<li><p>Replace All: replace the current and all future occurrences with the corrected word</p></li>
<li><p>Add: add the word to the user’s personal dictionary</p></li>
</ul>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">wx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enchant.checker</span> <span class="kn">import</span> <span class="n">SpellChecker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enchant.checker.wxSpellCheckerDialog</span> <span class="kn">import</span> <span class="n">wxSpellCheckerDialog</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">app</span> <span class="o">=</span> <span class="n">wx</span><span class="o">.</span><span class="n">PySimpleApp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;This is sme text with a fw speling errors in it. Here are a fw more to tst it ut.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dlg</span> <span class="o">=</span> <span class="n">wxSpellCheckerDialog</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span> <span class="o">=</span> <span class="n">SpellChecker</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dlg</span><span class="o">.</span><span class="n">SetSpellChecker</span><span class="p">(</span><span class="n">chkr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dlg</span><span class="o">.</span><span class="n">Show</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">app</span><span class="o">.</span><span class="n">MainLoop</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="cmdlinechecker">
<h3>CmdLineChecker<a class="headerlink" href="#cmdlinechecker" title="Permalink to this headline">¶</a></h3>
<p>The module enchant.checker.CmdLineChecker provides the class CmdLineChecker which can be used to interactively check the spelling of some text. It uses standard input and standard output to interact with the user through a command-line interface. The code below shows how to create and use this class from within a python application, along with a short sample checking session:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">enchant</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">enchant.checker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enchant.checker.CmdLineChecker</span> <span class="kn">import</span> <span class="n">CmdLineChecker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">checker</span><span class="o">.</span><span class="n">SpellChecker</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s2">&quot;this is sme example txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmdln</span> <span class="o">=</span> <span class="n">CmdLineChecker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmdln</span><span class="o">.</span><span class="n">set_checker</span><span class="p">(</span><span class="n">chkr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmdln</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="go">ERROR: sme</span>
<span class="go">HOW ABOUT: [&#39;some&#39;, &#39;same&#39;, &#39;Sm&#39;, &#39;Ame&#39;, &#39;ME&#39;, &#39;Me&#39;, &#39;SE&#39;, &#39;Se&#39;, &#39;me&#39;, &#39;Esme&#39;, &#39;Mme&#39;, &#39;SSE&#39;, &#39;See&#39;, &#39;Sue&#39;, &#39;see&#39;, &#39;sue&#39;, &#39;Ste&#39;, &quot;Sm&#39;s&quot;]</span>
<span class="go">&gt;&gt; help</span>
<span class="go">0..N: replace with the numbered suggestion</span>
<span class="go">R0..rN: always replace with the numbered suggestion</span>
<span class="go">i: ignore this word</span>
<span class="go">I: always ignore this word</span>
<span class="go">a: add word to personal dictionary</span>
<span class="go">e: edit the word</span>
<span class="go">q: quit checking</span>
<span class="go">h: print this help message</span>
<span class="go">----------------------------------------------------</span>
<span class="go">HOW ABOUT: [&#39;some&#39;, &#39;same&#39;, &#39;Sm&#39;, &#39;Ame&#39;, &#39;ME&#39;, &#39;Me&#39;, &#39;SE&#39;, &#39;Se&#39;, &#39;me&#39;, &#39;Esme&#39;, &#39;Mme&#39;, &#39;SSE&#39;, &#39;See&#39;, &#39;Sue&#39;, &#39;see&#39;, &#39;sue&#39;, &#39;Ste&#39;, &quot;Sm&#39;s&quot;]</span>
<span class="go">&gt;&gt; 0</span>
<span class="go">Replacing &#39;sme&#39; with &#39;some&#39;</span>
<span class="go">ERROR: txt</span>
<span class="go">HOW ABOUT: [&#39;text&#39;, &#39;TX&#39;, &#39;ext&#39;]</span>
<span class="go">&gt;&gt; i</span>
<span class="go">DONE</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
<span class="go">&#39;this is some example txt&#39;</span>
</pre></div>
</div>
<p>As shown by this simple example, the CmdLineChecker prints each error it encounters, along with a list of suggested replacements. The user enters the desired behavior using short alphanumeric commands, as explained by the output of the ‘help’ command.</p>
</div>
<div class="section" id="tokenization-splitting-text-into-words">
<h3>Tokenization: splitting text into words<a class="headerlink" href="#tokenization-splitting-text-into-words" title="Permalink to this headline">¶</a></h3>
<p>An important task in spellchecking is splitting a body of text up into its constitutive words, each of which is then passed to a Dict object for checking. PyEnchant provides the enchant.tokenize module to assist with this task. The purpose of this module is to provide an appropriate tokenization function which can be used to split the text. Usually, all that is required is the get_tokenizer function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enchant.tokenize</span> <span class="kn">import</span> <span class="n">get_tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span>
<span class="go">&lt;class enchant.tokenize.en.tokenize at 0x2aaaaab531d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;this is some simple text&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;this&#39;, 0), (&#39;is&#39;, 5), (&#39;some&#39;, 8), (&#39;simple&#39;, 13), (&#39;text&#39;, 20)]</span>
</pre></div>
</div>
<p>As shown in the example above, the function get_tokenizer takes a language tag as input, and returns a tokenization class that is appropriate for that language. Instantiating this class with some text returns an iterator which will yield the words contained in that text. This is exactly the mechanism that the SpellChecker class uses internally to split text into a series of words.</p>
<p>The items produced by the tokenizer are tuples of the form (WORD,POS) where WORD is the word which was found and POS is the position within the string at which that word begins.</p>
<div class="section" id="chunkers">
<h4>Chunkers<a class="headerlink" href="#chunkers" title="Permalink to this headline">¶</a></h4>
<p>In many applications, checkable text may be intermingled with some sort of markup (e.g. HTML tags) which does not need to be checked. To have the tokenizer return only those words that should be checked, it can be augmented with one or more chunkers.</p>
<p>A chunker is simply a special tokenizer function that breaks text up into large chunks rather than individual tokens. They are typically used by passing a list of chunkers to the get_tokenizer function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enchant.tokenize</span> <span class="kn">import</span> <span class="n">get_tokenizer</span><span class="p">,</span> <span class="n">HTMLChunker</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;this is &lt;span class=&#39;important&#39;&gt;really important&lt;/span&gt; text&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;this&#39;, 0), (&#39;is&#39;, 5), (&#39;span&#39;, 9), (&#39;class&#39;, 14), (&#39;important&#39;, 21), (&#39;really&#39;, 32), (&#39;important&#39;, 39), (&#39;span&#39;, 50), (&#39;text&#39;, 56)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="n">chunkers</span><span class="o">=</span><span class="p">(</span><span class="n">HTMLChunker</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;this is &lt;span class=&#39;important&#39;&gt;really important&lt;/span&gt; text&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;this&#39;, 0), (&#39;is&#39;, 5), (&#39;really&#39;, 32), (&#39;important&#39;, 39), (&#39;text&#39;, 56)]</span>
</pre></div>
</div>
<p>When the HTMLChunker is applied to the tokenizer, the &lt;span&gt; tag and its contents are removed from the list of words.</p>
<p>Currently the only implemented chunker is HTMLChunker. A chunker for LaTeX documents is in the works.</p>
</div>
<div class="section" id="filters">
<h4>Filters<a class="headerlink" href="#filters" title="Permalink to this headline">¶</a></h4>
<p>In many applications, it is common for spellchecking to ignore words that have a certain form. For example, when spellchecking an email it is customary to ignore email addresses and URLs. This can be achieved by augmenting the tokenization process with filters.</p>
<p>A filter is simply a wrapper around a tokenizer that can (1) drop certain words from the stream, and (2) further split words into sub-tokens. They are typically used by passing a list of filters to the get_tokenizer function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enchant.tokenize</span> <span class="kn">import</span> <span class="n">get_tokenizer</span><span class="p">,</span> <span class="n">EmailFilter</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;send an email to fake@example.com please&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;send&#39;, 0), (&#39;an&#39;, 5), (&#39;email&#39;, 8), (&#39;to&#39;, 14), (&#39;fake@example.com&#39;, 17), (&#39;please&#39;, 34)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">[</span><span class="n">EmailFilter</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;send an email to fake@example.com please&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;send&#39;, 0), (&#39;an&#39;, 5), (&#39;email&#39;, 8), (&#39;to&#39;, 14), (&#39;please&#39;, 34)]</span>
</pre></div>
</div>
<p>When the EmailFilter is applied to the tokenizer, the email address is removed from the list of words.</p>
<p>Currently implemented filters are EmailFilter, URLFilter and WikiWordFilter.</p>
</div>
</div>
</div>
<div class="section" id="advanced-pyenchant-usage">
<h2>Advanced PyEnchant Usage<a class="headerlink" href="#advanced-pyenchant-usage" title="Permalink to this headline">¶</a></h2>
<div class="section" id="providers">
<h3>Providers<a class="headerlink" href="#providers" title="Permalink to this headline">¶</a></h3>
<p>The underlying programming model provided by the Enchant library is based on the notion of Providers. A provider is a piece of code that provides spell-checking services which Enchant can use to perform its work. Different providers exist for performing spellchecking using different frameworks - for example there is an aspell provider and a MySpell provider.</p>
<p>In this way, enchant forms a “wrapper” around existing spellchecking tools in order to provide a common programming interface.</p>
<p>The provider which is managing a particular Dict object can be determined by accessing its provider attribute. This is a ProviderDesc object with the properties name, desc and file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">provider</span> <span class="o">&lt;</span><span class="n">Enchant</span><span class="p">:</span> <span class="n">Aspell</span> <span class="n">Provider</span><span class="o">&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">provider</span><span class="o">.</span><span class="n">name</span>
<span class="go">u&#39;aspell&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">provider</span><span class="o">.</span><span class="n">desc</span>
<span class="go">u&#39;Aspell Provider&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">provider</span><span class="o">.</span><span class="n">file</span>
<span class="go">u&#39;/usr/lib64/enchant/libenchant_aspell.so&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="brokers">
<h3>Brokers<a class="headerlink" href="#brokers" title="Permalink to this headline">¶</a></h3>
<p>The details of which provider is used to create a particular dictionary are managed by a Broker object. Such objects have methods for creating dictionaries and checking whether a particular dictionary exists, as shown in the example below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Broker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff810&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">dict_exists</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">dict_exists</span><span class="p">(</span><span class="s2">&quot;fake&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">list_languages</span><span class="p">()</span>
<span class="go">[&#39;en&#39;, &#39;en_CA&#39;, &#39;en_GB&#39;, &#39;en_US&#39;, &#39;eo&#39;, &#39;fr&#39;, &#39;fr_CH&#39;, &#39;fr_FR&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">request_dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">&lt;enchant.Dict object at 0x2aaaabdff8d0&gt;</span>
</pre></div>
</div>
<p>Brokers also have the method describe which determines which providers are available, and the method list_dicts which lists the dictionaries available through each provider:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Broker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
<span class="go">[&lt;Enchant: Aspell Provider&gt;, &lt;Enchant: Myspell Provider&gt;, &lt;Enchant: Ispell Provider&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">list_dicts</span><span class="p">()</span>
<span class="go">[(&#39;en&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;en_CA&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;en_GB&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;en_US&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;eo&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;fr&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;fr_CH&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;fr_FR&#39;, &lt;Enchant: Aspell Provider&gt;)]</span>
</pre></div>
</div>
<div class="section" id="the-default-broker">
<h4>The Default Broker<a class="headerlink" href="#the-default-broker" title="Permalink to this headline">¶</a></h4>
<p>In normal use, the functionality provided by brokers is not useful to the programmer. To make the programmer’s job easier, PyEnchant creates a default Broker object and uses it whenever one is not explicitly given. For example, the default broker is used when creating dictionary objects directly. This object is available as enchant._broker:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">_broker</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">_broker</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
</pre></div>
</div>
<p>You may have noticed that the top-level functions provided by the enchant module (such as request_dict, dict_exists and list_languages) match the methods provided by the Broker class. These functions are in fact the instance methods of the default Broker object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">_broker</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">request_dict</span><span class="o">.</span><span class="n">im_self</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">dict_exists</span><span class="o">.</span><span class="n">im_self</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="provider-ordering">
<span id="id1"></span><h4>Provider Ordering<a class="headerlink" href="#provider-ordering" title="Permalink to this headline">¶</a></h4>
<p>Which provider is used for which language is determined by the provider ordering of the Broker. This can be altered using the set_ordering method. This method accepts a language tag and a comma-separated list of provider names in the order that they should be checked. A language tag of “*” means that the ordering should be the default for all languages where an explicit ordering has not been given.</p>
<p>The following example states that for American English the MySpell provider should be tried first, followed by the aspell provider. For all other languages, the ordering is reversed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Broker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">set_ordering</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="s2">&quot;myspell,aspell&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">set_ordering</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span><span class="s2">&quot;aspell,myspell&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">request_dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">provider</span>
<span class="go">&lt;Enchant: Myspell Provider&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">request_dict</span><span class="p">(</span><span class="s2">&quot;en_GB&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">provider</span>
<span class="go">&lt;Enchant: Aspell Provider&gt;</span>
</pre></div>
</div>
<p>The user can also set their preferred ordering using enchant configuration files. For this reason, application programmers are discouraged from explicitly setting an ordering unless there is a compelling reason to do so.</p>
</div>
</div>
<div class="section" id="extending-enchant-tokenize">
<h3>Extending enchant.tokenize<a class="headerlink" href="#extending-enchant-tokenize" title="Permalink to this headline">¶</a></h3>
<p>As explained above, the module enchant.tokenize provides the ability to split text into its component words. The current implementation is based only on the rules for the English language, and so might not be completely suitable for your language of choice. Fortunately, it is straightforward to extend the functionality of this module.</p>
<p>To implement a new tokenization routine for the language TAG, simply create a class/function “tokenize” within the module “enchant.tokenize.TAG”. This function will automatically be detected by the module’s get_tokenizer function and used when appropriate. The easiest way to accomplish this is to copy the module “enchant.tokenize.en” and modify it to suit your needs.</p>
<p>The author would be very grateful for tokenization routines for languages other than English which can be incorporated back into the main PyEnchant distribution.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api/index.html" class="btn btn-neutral float-right" title="API Listing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="install.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2011, Ryan Kelly

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>